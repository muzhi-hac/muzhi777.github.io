<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Go 并发编程实践 | Helloworld</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content='Go 语言的并发模型以 Goroutine 和 Channel 为核心，能轻松构建高性能、可扩展的服务。本篇文章带你快速上手。
Goroutine 基础
Goroutine 是 Go 的轻量级线程，可以用 go 关键字创建：
func main() {
    go worker(1)
    go worker(2)
    time.Sleep(time.Second)
}

func worker(id int) {
    fmt.Printf("worker %d\n", id)
}
Channel 通讯
Channel 提供了 Goroutine 之间安全通信的方式：
func main() {
    ch := make(chan int)

    go func() {
        for i := 0; i < 3; i++ {
            ch <- i
        }
        close(ch)
    }()

    for v := range ch {
        fmt.Println("receive", v)
    }
}
select 复用
select 可以同时监听多个 Channel：
select {
case msg := <-ch1:
    fmt.Println("来自 ch1:", msg)
case msg := <-ch2:
    fmt.Println("来自 ch2:", msg)
case <-time.After(time.Second):
    fmt.Println("timeout")
}
并发安全
当多个 Goroutine 访问共享数据时，需要注意同步：'><meta name=generator content="Hugo 0.152.2"><meta name=robots content="index, follow"><link rel=stylesheet href=https://muzhi-hac.github.io/muzhi777.github.io/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css><link rel=canonical href=https://muzhi-hac.github.io/muzhi777.github.io/posts/golang-concurrency/><meta property="og:url" content="https://muzhi-hac.github.io/muzhi777.github.io/posts/golang-concurrency/"><meta property="og:site_name" content="Helloworld"><meta property="og:title" content="Go 并发编程实践"><meta property="og:description" content='Go 语言的并发模型以 Goroutine 和 Channel 为核心，能轻松构建高性能、可扩展的服务。本篇文章带你快速上手。
Goroutine 基础 Goroutine 是 Go 的轻量级线程，可以用 go 关键字创建：
func main() { go worker(1) go worker(2) time.Sleep(time.Second) } func worker(id int) { fmt.Printf("worker %d\n", id) } Channel 通讯 Channel 提供了 Goroutine 之间安全通信的方式：
func main() { ch := make(chan int) go func() { for i := 0; i < 3; i++ { ch <- i } close(ch) }() for v := range ch { fmt.Println("receive", v) } } select 复用 select 可以同时监听多个 Channel：
select { case msg := <-ch1: fmt.Println("来自 ch1:", msg) case msg := <-ch2: fmt.Println("来自 ch2:", msg) case <-time.After(time.Second): fmt.Println("timeout") } 并发安全 当多个 Goroutine 访问共享数据时，需要注意同步：'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-12T10:05:21+01:00"><meta property="article:modified_time" content="2025-11-12T10:05:21+01:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="并发"><meta property="article:tag" content="Goroutine"><meta property="article:tag" content="Channel"><meta itemprop=name content="Go 并发编程实践"><meta itemprop=description content='Go 语言的并发模型以 Goroutine 和 Channel 为核心，能轻松构建高性能、可扩展的服务。本篇文章带你快速上手。
Goroutine 基础 Goroutine 是 Go 的轻量级线程，可以用 go 关键字创建：
func main() { go worker(1) go worker(2) time.Sleep(time.Second) } func worker(id int) { fmt.Printf("worker %d\n", id) } Channel 通讯 Channel 提供了 Goroutine 之间安全通信的方式：
func main() { ch := make(chan int) go func() { for i := 0; i < 3; i++ { ch <- i } close(ch) }() for v := range ch { fmt.Println("receive", v) } } select 复用 select 可以同时监听多个 Channel：
select { case msg := <-ch1: fmt.Println("来自 ch1:", msg) case msg := <-ch2: fmt.Println("来自 ch2:", msg) case <-time.After(time.Second): fmt.Println("timeout") } 并发安全 当多个 Goroutine 访问共享数据时，需要注意同步：'><meta itemprop=datePublished content="2025-11-12T10:05:21+01:00"><meta itemprop=dateModified content="2025-11-12T10:05:21+01:00"><meta itemprop=wordCount content="132"><meta itemprop=keywords content="Golang,并发,Goroutine,Channel"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 并发编程实践"><meta name=twitter:description content='Go 语言的并发模型以 Goroutine 和 Channel 为核心，能轻松构建高性能、可扩展的服务。本篇文章带你快速上手。
Goroutine 基础 Goroutine 是 Go 的轻量级线程，可以用 go 关键字创建：
func main() { go worker(1) go worker(2) time.Sleep(time.Second) } func worker(id int) { fmt.Printf("worker %d\n", id) } Channel 通讯 Channel 提供了 Goroutine 之间安全通信的方式：
func main() { ch := make(chan int) go func() { for i := 0; i < 3; i++ { ch <- i } close(ch) }() for v := range ch { fmt.Println("receive", v) } } select 复用 select 可以同时监听多个 Channel：
select { case msg := <-ch1: fmt.Println("来自 ch1:", msg) case msg := <-ch2: fmt.Println("来自 ch2:", msg) case <-time.After(time.Second): fmt.Println("timeout") } 并发安全 当多个 Goroutine 访问共享数据时，需要注意同步：'></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=https://muzhi-hac.github.io/muzhi777.github.io/ class="f3 fw2 hover-white white-90 dib no-underline">Helloworld</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=https://muzhi-hac.github.io/muzhi777.github.io/ title="首页 page">首页</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=https://muzhi-hac.github.io/muzhi777.github.io/categories/devops/ title="DevOps page">DevOps</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=https://muzhi-hac.github.io/muzhi777.github.io/categories/golang/ title="Golang page">Golang</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=https://muzhi-hac.github.io/muzhi777.github.io/categories/tkn/ title="TKN page">TKN</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Go 并发编程实践</h1><time class="f6 mv4 dib tracked" datetime=2025-11-12T10:05:21+01:00>November 12, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Go 语言的并发模型以 Goroutine 和 Channel 为核心，能轻松构建高性能、可扩展的服务。本篇文章带你快速上手。</p><h2 id=goroutine-基础>Goroutine 基础</h2><p>Goroutine 是 Go 的轻量级线程，可以用 <code>go</code> 关键字创建：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>worker</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>worker</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;worker %d\n&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=channel-通讯>Channel 通讯</h2><p>Channel 提供了 Goroutine 之间安全通信的方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        close(<span style=color:#a6e22e>ch</span>)
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ch</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;receive&#34;</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=select-复用>select 复用</h2><p><code>select</code> 可以同时监听多个 Channel：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch1</span>:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;来自 ch1:&#34;</span>, <span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch2</span>:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;来自 ch2:&#34;</span>, <span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>After</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=并发安全>并发安全</h2><p>当多个 Goroutine 访问共享数据时，需要注意同步：</p><ul><li>使用 Channel 传递数据</li><li>使用 <code>sync.Mutex</code> 保护临界区</li><li>使用 <code>sync.WaitGroup</code> 等待多个 Goroutine 完成</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mu</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>counter</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>counter</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span></code></pre></div><h2 id=总结>总结</h2><p>Go 的 CSP 并发模型简单易用，通过 Goroutine + Channel 可以快速构建高并发程序。在实际项目中，合理设计 Goroutine 生命周期和通信协议是关键。</p><ul class=pa0><li class="list di"><a href=https://muzhi-hac.github.io/muzhi777.github.io/tags/golang/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Golang</a></li><li class="list di"><a href=https://muzhi-hac.github.io/muzhi777.github.io/tags/%E5%B9%B6%E5%8F%91/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">并发</a></li><li class="list di"><a href=https://muzhi-hac.github.io/muzhi777.github.io/tags/goroutine/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Goroutine</a></li><li class="list di"><a href=https://muzhi-hac.github.io/muzhi777.github.io/tags/channel/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Channel</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://muzhi-hac.github.io/muzhi777.github.io/>&copy; Helloworld 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>